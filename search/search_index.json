{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-code Laminas\\Code\\Generator provides facilities to generate arbitrary code using an object-oriented interface, both to create new code as well as to update existing code. While the current implementation is limited to generating PHP code, you can easily extend the base class in order to provide code generation for other tasks: JavaScript, configuration files, apache vhosts, etc. File issues at https://github.com/laminas/laminas-code/issues Documentation is at https://docs.laminas.dev/laminas-code/ Migration documentation from v2 to v3 is at https://docs.laminas.dev/laminas-code/migration/","title":"Home"},{"location":"#laminas-code","text":"Laminas\\Code\\Generator provides facilities to generate arbitrary code using an object-oriented interface, both to create new code as well as to update existing code. While the current implementation is limited to generating PHP code, you can easily extend the base class in order to provide code generation for other tasks: JavaScript, configuration files, apache vhosts, etc. File issues at https://github.com/laminas/laminas-code/issues Documentation is at https://docs.laminas.dev/laminas-code/ Migration documentation from v2 to v3 is at https://docs.laminas.dev/laminas-code/migration/","title":"laminas-code"},{"location":"migration/","text":"Migrating from laminas-code v2 to v3 string , int , float , bool are no longer ignored In 2.x, a Laminas\\Code\\Generator\\ParameterGenerator with name foo and type string , int , float or bool simply generated code \"$foo\" : $generator = new \\Laminas\\Code\\ParameterGenerator('foo'); $generator->setType('string'); echo $generator->generate(); // \"$foo\" In 3.x, this code will instead produce \"string $foo\" . If you generate code that should run in PHP 5.x, it is advisable to strip string , int , float and bool from type definitions passed to Laminas\\Code\\ParameterGenerator instances. The quickest way is to set the type to null , if it matches any of these scalar types: if (in_array($type, ['string', 'int', 'float', 'bool'])) { $type = null; } $generator->setType($type); ParameterReflection::getType() changes PHP 7 introduced ReflectionParameter#getType() . In order to not override this method, Laminas\\Code\\Reflection\\ParameterReflection#getType() was renamed to Laminas\\Code\\Reflection\\ParameterReflection#detectType() . If you relied on Laminas\\Code\\Reflection\\ParameterReflection#getType() , you can simply replace the method calls in your code. DocBlock types ignored by ParameterGenerator::fromReflection() As a direct consequence of the previous change, calls to Laminas\\Code\\Generator\\ParameterGenerator::fromReflection() will not mirror the type hints read from a method's DocBlock. As an example, take following code: class Foo { /** * @param string $baz */ public function bar($baz) { } } $methodGenerator = \\Laminas\\Code\\Generator\\MethodGenerator::fromReflection( new \\Laminas\\Code\\Reflection\\MethodReflection('Foo', 'bar') ); var_dump($methodGenerator->getParameters()[0]->getType()); In version 2.x, this code produces \"string\" , in version 3.x it returns null . If you need to rely on the types in the annotations, please use Laminas\\Code\\Reflection\\ParameterReflection#detectType() instead, and build a MethodGenerator instance manually. This change is required: since signatures in PHP 7 include scalar type hints. That also means that reflecting scalar type hints from DocBlocks into the signature of a generated method may lead to fatal errors (due to signature mismatch) at runtime. Type strings are validated If you attempt to generate type-hints for parameters or return types, those types are now validated before the code is generated. Be sure to check which values you pass to Laminas\\Code\\Generator\\MethodGenerator#setReturnType() or Laminas\\Code\\Generator\\ParameterGenerator#setType() , as you may incur in a Laminas\\Code\\Generator\\Exception\\InvalidArgumentException being thrown if any of those types are invalid strings: $parameterGenerator->setType('foo'); // valid $parameterGenerator->setType('array'); // valid $parameterGenerator->setType('bool'); // valid $parameterGenerator->setType('123'); // invalid (throws exception) $parameterGenerator->setType(''); // invalid (throws exception) $parameterGenerator->setType('*'); // invalid (throws exception) $parameterGenerator->setType('\\\\'); // invalid (throws exception) Generated type-hints are now prefixed by \"\\\" Generated type-hints are now prefixed with the NAMESPACE_SEPARATOR , \"\\\" . Take following example code: $parameter = new \\Laminas\\Code\\Generator\\ParameterGenerator('bar', 'baz'); $method = new \\Laminas\\Code\\Generator\\MethodGenerator('foo', [$parameter]); $method->setReturnType('tab'); echo $method->generate(); This code produces public function foo(baz $bar) {} in 2.x. In version 3.x, it produces public function foo(\\baz $bar) : \\tab {} . In order to avoid migration problems, be sure to always pass fully qualified class names to Laminas\\Code\\Generator\\MethodGenerator and Laminas\\Code\\Generator\\ParameterGenerator . ParameterGenerator::$simple was removed If you extended Laminas\\Code\\Generator\\ParameterGenerator , be sure to check if you are accessing the protected static variable $simple : it was removed, and you should adapt your code by either copying it into your class or avoiding its usage. ParameterGenerator::$type has changed If you extended Laminas\\Code\\Generator\\ParameterGenerator , be sure to check if you are accessing the protected variable $type : its type has changed. While it can still be used as a string via an explicit (string) cast, the type of this protected member is now null|Laminas\\Code\\Generator\\TypeGenerator .","title":"Migration"},{"location":"migration/#migrating-from-laminas-code-v2-to-v3","text":"","title":"Migrating from laminas-code v2 to v3"},{"location":"migration/#string-int-float-bool-are-no-longer-ignored","text":"In 2.x, a Laminas\\Code\\Generator\\ParameterGenerator with name foo and type string , int , float or bool simply generated code \"$foo\" : $generator = new \\Laminas\\Code\\ParameterGenerator('foo'); $generator->setType('string'); echo $generator->generate(); // \"$foo\" In 3.x, this code will instead produce \"string $foo\" . If you generate code that should run in PHP 5.x, it is advisable to strip string , int , float and bool from type definitions passed to Laminas\\Code\\ParameterGenerator instances. The quickest way is to set the type to null , if it matches any of these scalar types: if (in_array($type, ['string', 'int', 'float', 'bool'])) { $type = null; } $generator->setType($type);","title":"string, int, float, bool are no longer ignored"},{"location":"migration/#parameterreflectiongettype-changes","text":"PHP 7 introduced ReflectionParameter#getType() . In order to not override this method, Laminas\\Code\\Reflection\\ParameterReflection#getType() was renamed to Laminas\\Code\\Reflection\\ParameterReflection#detectType() . If you relied on Laminas\\Code\\Reflection\\ParameterReflection#getType() , you can simply replace the method calls in your code.","title":"ParameterReflection::getType() changes"},{"location":"migration/#docblock-types-ignored-by-parametergeneratorfromreflection","text":"As a direct consequence of the previous change, calls to Laminas\\Code\\Generator\\ParameterGenerator::fromReflection() will not mirror the type hints read from a method's DocBlock. As an example, take following code: class Foo { /** * @param string $baz */ public function bar($baz) { } } $methodGenerator = \\Laminas\\Code\\Generator\\MethodGenerator::fromReflection( new \\Laminas\\Code\\Reflection\\MethodReflection('Foo', 'bar') ); var_dump($methodGenerator->getParameters()[0]->getType()); In version 2.x, this code produces \"string\" , in version 3.x it returns null . If you need to rely on the types in the annotations, please use Laminas\\Code\\Reflection\\ParameterReflection#detectType() instead, and build a MethodGenerator instance manually. This change is required: since signatures in PHP 7 include scalar type hints. That also means that reflecting scalar type hints from DocBlocks into the signature of a generated method may lead to fatal errors (due to signature mismatch) at runtime.","title":"DocBlock types ignored by ParameterGenerator::fromReflection()"},{"location":"migration/#type-strings-are-validated","text":"If you attempt to generate type-hints for parameters or return types, those types are now validated before the code is generated. Be sure to check which values you pass to Laminas\\Code\\Generator\\MethodGenerator#setReturnType() or Laminas\\Code\\Generator\\ParameterGenerator#setType() , as you may incur in a Laminas\\Code\\Generator\\Exception\\InvalidArgumentException being thrown if any of those types are invalid strings: $parameterGenerator->setType('foo'); // valid $parameterGenerator->setType('array'); // valid $parameterGenerator->setType('bool'); // valid $parameterGenerator->setType('123'); // invalid (throws exception) $parameterGenerator->setType(''); // invalid (throws exception) $parameterGenerator->setType('*'); // invalid (throws exception) $parameterGenerator->setType('\\\\'); // invalid (throws exception)","title":"Type strings are validated"},{"location":"migration/#generated-type-hints-are-now-prefixed-by","text":"Generated type-hints are now prefixed with the NAMESPACE_SEPARATOR , \"\\\" . Take following example code: $parameter = new \\Laminas\\Code\\Generator\\ParameterGenerator('bar', 'baz'); $method = new \\Laminas\\Code\\Generator\\MethodGenerator('foo', [$parameter]); $method->setReturnType('tab'); echo $method->generate(); This code produces public function foo(baz $bar) {} in 2.x. In version 3.x, it produces public function foo(\\baz $bar) : \\tab {} . In order to avoid migration problems, be sure to always pass fully qualified class names to Laminas\\Code\\Generator\\MethodGenerator and Laminas\\Code\\Generator\\ParameterGenerator .","title":"Generated type-hints are now prefixed by \"\\\""},{"location":"migration/#parametergeneratorsimple-was-removed","text":"If you extended Laminas\\Code\\Generator\\ParameterGenerator , be sure to check if you are accessing the protected static variable $simple : it was removed, and you should adapt your code by either copying it into your class or avoiding its usage.","title":"ParameterGenerator::$simple was removed"},{"location":"migration/#parametergeneratortype-has-changed","text":"If you extended Laminas\\Code\\Generator\\ParameterGenerator , be sure to check if you are accessing the protected variable $type : its type has changed. While it can still be used as a string via an explicit (string) cast, the type of this protected member is now null|Laminas\\Code\\Generator\\TypeGenerator .","title":"ParameterGenerator::$type has changed"},{"location":"generator/examples/","text":"Laminas\\Code\\Generator Examples Generating PHP classes The following example generates an empty class with a class-level DocBlock. use Laminas\\Code\\Generator\\ClassGenerator; use Laminas\\Code\\Generator\\DocBlockGenerator; $foo = new ClassGenerator(); $docblock = DocBlockGenerator::fromArray([ 'shortDescription' => 'Sample generated class', 'longDescription' => 'This is a class generated with Laminas\\Code\\Generator.', 'tags' => [ [ 'name' => 'version', 'description' => '$Rev:$', ], [ 'name' => 'license', 'description' => 'New BSD', ], ], ]); $foo->setName('Foo') ->setDocblock($docblock); echo $foo->generate(); The above code will result in the following: /** * Sample generated class * * This is a class generated with Laminas\\Code\\Generator. * * @version $Rev:$ * @license New BSD * */ class Foo { } Generating PHP classes with class properties Building on the previous example, we now add properties to our generated class. use Laminas\\Code\\Generator\\ClassGenerator; use Laminas\\Code\\Generator\\DocBlockGenerator; use Laminas\\Code\\Generator\\PropertyGenerator; $foo = new ClassGenerator(); $docblock = DocBlockGenerator::fromArray([ 'shortDescription' => 'Sample generated class', 'longDescription' => 'This is a class generated with Laminas\\Code\\Generator.', 'tags' => [ [ 'name' => 'version', 'description' => '$Rev:$', ], [ 'name' => 'license', 'description' => 'New BSD', ], ], ]); $foo->setName('Foo') ->setDocblock($docblock) ->addProperties([ ['_bar', 'baz', PropertyGenerator::FLAG_PROTECTED], ['baz', 'bat', PropertyGenerator::FLAG_PUBLIC] ]) ->addConstants([ ['bat', 'foobarbazbat'] ]); echo $foo->generate(); The above results in the following class definition: /** * Sample generated class * * This is a class generated with Laminas\\Code\\Generator. * * @version $Rev:$ * @license New BSD * */ class Foo { protected $_bar = 'baz'; public $baz = 'bat'; const bat = 'foobarbazbat'; } Generating PHP classes with class methods Laminas\\Code\\Generator\\ClassGenerator allows you to attach methods with optional content to your classes. Methods may be attached as either arrays or concrete Laminas\\Code\\Generator\\MethodGenerator instances. use Laminas\\Code\\Generator\\ClassGenerator; use Laminas\\Code\\Generator\\DocBlockGenerator; use Laminas\\Code\\Generator\\DocBlock\\Tag; use Laminas\\Code\\Generator\\MethodGenerator; use Laminas\\Code\\Generator\\PropertyGenerator; $foo = new ClassGenerator(); $docblock = DocBlockGenerator::fromArray([ 'shortDescription' => 'Sample generated class', 'longDescription' => 'This is a class generated with Laminas\\Code\\Generator.', 'tags' => [ [ 'name' => 'version', 'description' => '$Rev:$', ], [ 'name' => 'license', 'description' => 'New BSD', ], ], ]); $foo->setName('Foo') ->setDocblock($docblock) ->addProperties([ ['_bar', 'baz', PropertyGenerator::FLAG_PROTECTED], ['baz', 'bat', PropertyGenerator::FLAG_PUBLIC] ]) ->addConstants([ ['bat', 'foobarbazbat', PropertyGenerator::FLAG_CONSTANT] ]) ->addMethods([ // Method passed as array MethodGenerator::fromArray([ 'name' => 'setBar', 'parameters' => ['bar'], 'body' => '$this->_bar = $bar;' . \"\\n\" . 'return $this;', 'docblock' => DocBlockGenerator::fromArray([ 'shortDescription' => 'Set the bar property', 'longDescription' => null, 'tags' => [ new Tag\\ParamTag([ 'paramName' => 'bar', 'datatype' => 'string' ]), new Tag\\ReturnTag([ 'datatype' => 'string', ]), ], ]), ]), // Method passed as concrete instance new MethodGenerator( 'getBar', [], MethodGenerator::FLAG_PUBLIC, 'return $this->_bar;', DocBlockGenerator::fromArray([ 'shortDescription' => 'Retrieve the bar property', 'longDescription' => null, 'tags' => [ new Tag\\ReturnTag([ 'datatype' => 'string|null', ]), ], ]) ), ]); echo $foo->generate(); The above generates the following output: /** * Sample generated class * * This is a class generated with Laminas\\Code\\Generator. * * @version $Rev:$ * @license New BSD */ class Foo { protected $_bar = 'baz'; public $baz = 'bat'; const bat = 'foobarbazbat'; /** * Set the bar property * * @param string bar * @return string */ public function setBar($bar) { $this->_bar = $bar; return $this; } /** * Retrieve the bar property * * @return string|null */ public function getBar() { return $this->_bar; } } Generating PHP files Laminas\\Code\\Generator\\FileGenerator can be used to generate the contents of a PHP file. You can include classes as well as arbitrary content body. When attaching classes, you should attach either concrete Laminas\\Code\\Generator\\ClassGenerator instances or an array defining the class. In the example below, we will assume you've defined $foo per one of the class definitions in a previous example. use Laminas\\Code\\Generator\\DocBlockGenerator; use Laminas\\Code\\Generator\\FileGenerator; $file = FileGenerator::fromArray([ 'classes' => [$foo], 'docblock' => DocBlockGenerator::fromArray([ 'shortDescription' => 'Foo class file', 'longDescription' => null, 'tags' => [ [ 'name' => 'license', 'description' => 'New BSD', ], ], ]), 'body' => 'define(\\'APPLICATION_ENV\\', \\'testing\\');', ]); Calling generate() will generate the code -- but not write it to a file. You will need to capture the contents and write them to a file yourself. As an example: $code = $file->generate(); file_put_contents('Foo.php', $code); The above will generate the following file: <?php /** * Foo class file * * @license New BSD */ /** * Sample generated class * * This is a class generated with Laminas\\Code\\Generator. * * @version $Rev:$ * @license New BSD */ class Foo { protected $_bar = 'baz'; public $baz = 'bat'; const bat = 'foobarbazbat'; /** * Set the bar property * * @param string bar * @return string */ public function setBar($bar) { $this->_bar = $bar; return $this; } /** * Retrieve the bar property * * @return string|null */ public function getBar() { return $this->_bar; } } define('APPLICATION_ENV', 'testing'); Add code to existing PHP files and classes Seeding PHP file code generation via reflection You can add PHP code to an existing PHP file using the code generator. To do so, you need to first do reflection on it. The static method fromReflectedFileName() allows you to do this. $generator = Laminas\\Code\\Generator\\FileGenerator::fromReflectedFileName($path); $generator->setBody(\"\\$foo->bar();\"); file_put_contents($path, $generator->generate()); Seeding PHP class generation via reflection You may add code to an existing class. To do so, first use the static fromReflection() method to map the class into a generator object. From there, you may add additional properties or methods, and then regenerate the class. use Laminas\\Code\\Generator\\ClassGenerator; use Laminas\\Code\\Generator\\DocBlockGenerator; use Laminas\\Code\\Generator\\DocBlock\\Tag; use Laminas\\Code\\Generator\\MethodGenerator; use Laminas\\Code\\Reflection\\ClassReflection; $generator = ClassGenerator::fromReflection( new ClassReflection($class) ); $generator->addMethod( 'setBaz', ['baz'], MethodGenerator::FLAG_PUBLIC, '$this->_baz = $baz;' . \"\\n\" . 'return $this;', DocBlockGenerator::fromArray([ 'shortDescription' => 'Set the baz property', 'longDescription' => null, 'tags' => [ new Tag\\ParamTag([ 'paramName' => 'baz', 'datatype' => 'string' ]), new Tag\\ReturnTag([ 'datatype' => 'string', ]), ], ]) ); $code = $generator->generate();","title":"Examples"},{"location":"generator/examples/#laminascodegenerator-examples","text":"","title":"Laminas\\Code\\Generator Examples"},{"location":"generator/examples/#generating-php-classes","text":"The following example generates an empty class with a class-level DocBlock. use Laminas\\Code\\Generator\\ClassGenerator; use Laminas\\Code\\Generator\\DocBlockGenerator; $foo = new ClassGenerator(); $docblock = DocBlockGenerator::fromArray([ 'shortDescription' => 'Sample generated class', 'longDescription' => 'This is a class generated with Laminas\\Code\\Generator.', 'tags' => [ [ 'name' => 'version', 'description' => '$Rev:$', ], [ 'name' => 'license', 'description' => 'New BSD', ], ], ]); $foo->setName('Foo') ->setDocblock($docblock); echo $foo->generate(); The above code will result in the following: /** * Sample generated class * * This is a class generated with Laminas\\Code\\Generator. * * @version $Rev:$ * @license New BSD * */ class Foo { }","title":"Generating PHP classes"},{"location":"generator/examples/#generating-php-files","text":"Laminas\\Code\\Generator\\FileGenerator can be used to generate the contents of a PHP file. You can include classes as well as arbitrary content body. When attaching classes, you should attach either concrete Laminas\\Code\\Generator\\ClassGenerator instances or an array defining the class. In the example below, we will assume you've defined $foo per one of the class definitions in a previous example. use Laminas\\Code\\Generator\\DocBlockGenerator; use Laminas\\Code\\Generator\\FileGenerator; $file = FileGenerator::fromArray([ 'classes' => [$foo], 'docblock' => DocBlockGenerator::fromArray([ 'shortDescription' => 'Foo class file', 'longDescription' => null, 'tags' => [ [ 'name' => 'license', 'description' => 'New BSD', ], ], ]), 'body' => 'define(\\'APPLICATION_ENV\\', \\'testing\\');', ]); Calling generate() will generate the code -- but not write it to a file. You will need to capture the contents and write them to a file yourself. As an example: $code = $file->generate(); file_put_contents('Foo.php', $code); The above will generate the following file: <?php /** * Foo class file * * @license New BSD */ /** * Sample generated class * * This is a class generated with Laminas\\Code\\Generator. * * @version $Rev:$ * @license New BSD */ class Foo { protected $_bar = 'baz'; public $baz = 'bat'; const bat = 'foobarbazbat'; /** * Set the bar property * * @param string bar * @return string */ public function setBar($bar) { $this->_bar = $bar; return $this; } /** * Retrieve the bar property * * @return string|null */ public function getBar() { return $this->_bar; } } define('APPLICATION_ENV', 'testing');","title":"Generating PHP files"},{"location":"generator/examples/#add-code-to-existing-php-files-and-classes","text":"","title":"Add code to existing PHP files and classes"},{"location":"generator/intro/","text":"Introduction Laminas\\Code\\Generator provides facilities to generate arbitrary code using an object-oriented interface, both to create new code as well as to update existing code. While the current implementation is limited to generating PHP code, you can easily extend the base class in order to provide code generation for other tasks: JavaScript, configuration files, apache vhosts, etc. Theory of Operation In the most typical use case, you will simply instantiate a code generator class and either pass it the appropriate configuration or configure it after instantiation. To generate the code, you will simply echo the object or call its generate() method. // Passing configuration to the constructor: $file = new Laminas\\Code\\Generator\\FileGenerator(array( 'classes' => array( new Laminas\\Code\\Generator\\ClassGenerator( 'World', // name null, // namespace null, // flags null, // extends array(), // interfaces array(), // properties array( new Laminas\\Code\\Generator\\MethodGenerator( 'hello', // name array(), // parameters 'public', // visibility 'echo \\'Hello world!\\';' // body ), ) ), ), )); // Render the generated file echo $file->generate(); // or write it to a file: file_put_contents('World.php', $file->generate()); // OR // Configuring after instantiation $method = new Laminas\\Code\\Generator\\MethodGenerator(); $method->setName('hello') ->setBody('echo \\'Hello world!\\';'); $class = new Laminas\\Code\\Generator\\ClassGenerator(); $class->setName('World') ->addMethodFromGenerator($method); $file = new Laminas\\Code\\Generator\\FileGenerator(); $file->setClass($class); // Render the generated file echo $file->generate(); // or write it to a file: file_put_contents('World.php', $file->generate()); Both of the above samples will render the same result: <?php class World { public function hello() { echo 'Hello world!'; } } Another common use case is to update existing code -- for instance, to add a method to a class. In such a case, you must first inspect the existing code using reflection, and then add your new method. Laminas\\Code\\Generator makes this trivially simple, by leveraging Laminas\\Code\\Reflection . As an example, let's say we've saved the above to the file World.php , and have already included it. We could then do the following: $class = Laminas\\Code\\Generator\\ClassGenerator::fromReflection( new Laminas\\Code\\Reflection\\ClassReflection('World') ); $method = new Laminas\\Code\\Generator\\MethodGenerator(); $method->setName('mrMcFeeley') ->setBody('echo \\'Hello, Mr. McFeeley!\\';'); $class->addMethodFromGenerator($method); $file = new Laminas\\Code\\Generator\\FileGenerator(); $file->setClass($class); // Render the generated file echo $file->generate(); // Or, better yet, write it back to the original file: file_put_contents('World.php', $file->generate()); The resulting class file will now look like this: <?php class World { public function hello() { echo 'Hello world!'; } public function mrMcFeeley() { echo 'Hellow Mr. McFeeley!'; } }","title":"Introduction"},{"location":"generator/intro/#introduction","text":"Laminas\\Code\\Generator provides facilities to generate arbitrary code using an object-oriented interface, both to create new code as well as to update existing code. While the current implementation is limited to generating PHP code, you can easily extend the base class in order to provide code generation for other tasks: JavaScript, configuration files, apache vhosts, etc.","title":"Introduction"},{"location":"generator/intro/#theory-of-operation","text":"In the most typical use case, you will simply instantiate a code generator class and either pass it the appropriate configuration or configure it after instantiation. To generate the code, you will simply echo the object or call its generate() method. // Passing configuration to the constructor: $file = new Laminas\\Code\\Generator\\FileGenerator(array( 'classes' => array( new Laminas\\Code\\Generator\\ClassGenerator( 'World', // name null, // namespace null, // flags null, // extends array(), // interfaces array(), // properties array( new Laminas\\Code\\Generator\\MethodGenerator( 'hello', // name array(), // parameters 'public', // visibility 'echo \\'Hello world!\\';' // body ), ) ), ), )); // Render the generated file echo $file->generate(); // or write it to a file: file_put_contents('World.php', $file->generate()); // OR // Configuring after instantiation $method = new Laminas\\Code\\Generator\\MethodGenerator(); $method->setName('hello') ->setBody('echo \\'Hello world!\\';'); $class = new Laminas\\Code\\Generator\\ClassGenerator(); $class->setName('World') ->addMethodFromGenerator($method); $file = new Laminas\\Code\\Generator\\FileGenerator(); $file->setClass($class); // Render the generated file echo $file->generate(); // or write it to a file: file_put_contents('World.php', $file->generate()); Both of the above samples will render the same result: <?php class World { public function hello() { echo 'Hello world!'; } } Another common use case is to update existing code -- for instance, to add a method to a class. In such a case, you must first inspect the existing code using reflection, and then add your new method. Laminas\\Code\\Generator makes this trivially simple, by leveraging Laminas\\Code\\Reflection . As an example, let's say we've saved the above to the file World.php , and have already included it. We could then do the following: $class = Laminas\\Code\\Generator\\ClassGenerator::fromReflection( new Laminas\\Code\\Reflection\\ClassReflection('World') ); $method = new Laminas\\Code\\Generator\\MethodGenerator(); $method->setName('mrMcFeeley') ->setBody('echo \\'Hello, Mr. McFeeley!\\';'); $class->addMethodFromGenerator($method); $file = new Laminas\\Code\\Generator\\FileGenerator(); $file->setClass($class); // Render the generated file echo $file->generate(); // Or, better yet, write it back to the original file: file_put_contents('World.php', $file->generate()); The resulting class file will now look like this: <?php class World { public function hello() { echo 'Hello world!'; } public function mrMcFeeley() { echo 'Hellow Mr. McFeeley!'; } }","title":"Theory of Operation"},{"location":"generator/reference/","text":"Laminas\\Code\\Generator Reference Abstract Classes and Interfaces Laminas\\Code\\Generator\\GeneratorInterface The base interface from which all CodeGenerator classes implement provides the minimal functionality necessary. It's API is as follows: interface Laminas\\Code\\Generator\\GeneratorInterface { public function generate(); } Laminas\\Code\\Generator\\AbstractGenerator Laminas\\Code\\Generator\\AbstractGenerator implements Laminas\\Code\\Generator\\GeneratorInterface , and adds some properties for tracking whether content has changed as well as the amount of indentation that should appear before generated content. Its API is as follows: abstract class Laminas\\Code\\Generator\\AbstractGenerator implements Laminas\\Code\\Generator\\GeneratorInterface { public function __construct(Array|Traversable $options = []) public function setOptions(Array $options) public function setSourceContent($sourceContent) public function getSourceContent() public function setSourceDirty($isSourceDirty = true) public function isSourceDirty() public function setIndentation($indentation) public function getIndentation() } The constructor passes the $options parameter to setOptions() . Like most classes in Laminas, setOptions() compares an option key to existing setters in the class, and passes the value on to that method if found. setSourceContent() and getSourceContent() are intended to either set the default content for the code being generated, or to replace said content once all generation tasks are complete. Laminas\\Code\\Generator\\AbstractMemberGenerator Laminas\\Code\\Generator\\AbstractMemberGenerator is a base class for generating class members -- properties and methods -- and provides accessors and mutators for establishing visibility; whether or not the member is abstract, static, or final; and the name of the member. Its API is as follows: abstract class Laminas\\Code\\Generator\\AbstractMemberGenerator extends Laminas\\Code\\Generator\\AbstractGenerator { public function setAbstract($isAbstract) public function isAbstract() public function setStatic($isStatic) public function isStatic() public function setVisibility($visibility) public function getVisibility() public function setName($name) public function getName() } Concrete CodeGenerator Classes Laminas\\Code\\Generator\\BodyGenerator Laminas\\Code\\Generator\\BodyGenerator is intended for generating arbitrary procedural code to include within a file. As such, you simply set content for the object, and it will return that content when you invoke generate() . The API of the class is as follows: class Laminas\\Code\\Generator\\BodyGenerator extends Laminas\\Code\\Generator\\AbstractGenerator { public function setContent($content) public function getContent() public function generate() } Laminas\\Code\\Generator\\ClassGenerator Laminas\\Code\\Generator\\ClassGenerator is intended for generating PHP classes. The basic functionality just generates the PHP class itself, as well as optionally the related PHP DocBlock. Classes may implement or inherit from other classes, and may be marked as abstract. Utilizing other code generator classes, you can also attach class constants, properties, and methods. The API is as follows: class Laminas\\Code\\Generator\\ClassGenerator extends Laminas\\Code\\Generator\\AbstractGenerator { public static function fromReflection( Laminas\\Code\\Reflection\\ClassReflection $reflectionClass ) public function addConstants(Array $properties) public function addConstant($property) public function getConstants() public function getConstant($propertyName) public function removeConstant($constantName) public function setDocblock(Laminas\\Code\\Generator\\DocBlockGenerator $docblock) public function getDocblock() public function setName($name) public function getName() public function setAbstract($isAbstract) public function isAbstract() public function setExtendedClass($extendedClass) public function getExtendedClass() public function hasExtentedClass() public function removeExtentedClass() public function setImplementedInterfaces(Array $implementedInterfaces) public function getImplementedInterfaces() public function addProperties(Array $properties) public function addProperty($property) public function getProperties() public function getProperty($propertyName) public function removeProperty($propertyName) public function addMethods(Array $methods) public function addMethod( $name, Array $parameters = [], $flags = Laminas\\Code\\Generator\\MethodGenerator::FLAG_PUBLIC, $body = null, $docBlock = null ) public function getMethods() public function getMethod($methodName) public function hasMethod($methodName) public function hasUse($use) public function removeUse($use) public function hasUseAlias($use) public function removeUseAlias($use) public function hasImplementedInterface($implementedInterface) public function removeImplementedInterface($implementedInterface) public function isSourceDirty() public function generate() } The addProperty() method accepts an array of information that may be used to generate a Laminas\\Code\\Generator\\PropertyGenerator instance -- or simply an instance of Laminas\\Code\\Generator\\PropertyGenerator . Likewise, addMethod() accepts either an array of information for generating a Laminas\\Code\\Generator\\MethodGenerator instance or a concrete instance of that class. Note that setDocBlock() expects an instance of Laminas\\Code\\Generator\\DocBlockGenerator . Laminas\\Code\\Generator\\DocBlockGenerator Laminas\\Code\\Generator\\DocBlockGenerator can be used to generate arbitrary PHP docblocks, including all the standard docblock features: short and long descriptions and annotation tags. Annotation tags may be set using the setTag() and setTags() methods; these each take either an array describing the tag that may be passed to the Laminas\\Code\\Generator\\DocBlock\\Tag constructor, or an instance of that class. The API is as follows: class Laminas\\Code\\Generator\\DocBlockGenerator extends Laminas\\Code\\Generator\\AbstractGenerator { public static function fromReflection( Laminas\\Code\\Reflection\\DocblockReflection $reflectionDocblock ) public function setShortDescription($shortDescription) public function getShortDescription() public function setLongDescription($longDescription) public function getLongDescription() public function setTags(Array $tags) public function setTag($tag) public function getTags() public function generate() } Laminas\\Code\\Generator\\DocBlock\\Tag Laminas\\Code\\Generator\\DocBlock\\Tag is intended for creating arbitrary annotation tags for inclusion in PHP docblocks. Tags are expected to contain a name (the portion immediately following the '@' symbol) and a description (everything following the tag name). The class API is as follows: class Laminas\\Code\\Generator\\DocBlock\\Tag extends Laminas\\Code\\Generator\\AbstractGenerator { public static function fromReflection( Laminas\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTag ) public function setName($name) public function getName() public function setDescription($description) public function getDescription() public function generate() } Laminas\\Code\\Generator\\DocBlock\\Tag\\ParamTag Laminas\\Code\\Generator\\DocBlock\\Tag\\ParamTag is a specialized version of Laminas\\Code\\Generator\\DocBlock\\Tag , and represents a method parameter. The tag name is therefor known (\"param\"), but due to the format of this annotation tag, additional information is required in order to generate it: the parameter name and data type it represents. The class API is as follows: class Laminas\\Code\\Generator\\DocBlock\\Tag\\ParamTag extends Laminas\\Code\\Generator\\DocBlock\\Tag { public static function fromReflection( Laminas\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTagParam ) public function setDatatype($datatype) public function getDatatype() public function setParamName($paramName) public function getParamName() public function generate() } Laminas\\Code\\Generator\\DocBlock\\Tag\\ReturnTag Like the param docblock tag variant, Laminas\\Code\\Generator\\DocBlock\\Tag\\ReturnTag is an annotation tag variant for representing a method return value. In this case, the annotation tag name is known (\"return\"), but requires a return type. The class API is as follows: class Laminas\\Code\\Generator\\DocBlock\\Tag\\ParamTag extends Laminas\\Code\\Generator\\DocBlock\\Tag { public static function fromReflection( Laminas\\Code\\Reflection\\DocBlock\\Tag\\TagInterface $reflectionTagReturn ) public function setDatatype($datatype) public function getDatatype() public function generate() } Laminas\\Code\\Generator\\FileGenerator Laminas\\Code\\Generator\\FileGenerator is used to generate the full contents of a file that will contain PHP code. The file may contain classes or arbitrary PHP code, as well as a file-level docblock if desired. When adding classes to the file, you will need to pass either an array of information to pass to the Laminas\\Code\\Generator\\ClassGenerator constructor, or an instance of that class. Similarly, with docblocks, you will need to pass information for the Laminas\\Code\\Generator\\DocBlockGenerator constructor to consume or an instance of the class. The API of the class is as follows: class Laminas\\Code\\Generator\\FileGenerator extends Laminas\\Code\\Generator\\AbstractGenerator { public static function fromReflectedFilePath( $filePath, $usePreviousCodeGeneratorIfItExists = true, $includeIfNotAlreadyIncluded = true) public static function fromReflection(Laminas\\Code\\Reflection\\FileReflection $reflectionFile) public function setDocblock(Laminas\\Code\\Generator\\DocBlockGenerator $docblock) public function getDocblock() public function setRequiredFiles($requiredFiles) public function getRequiredFiles() public function setClasses(Array $classes) public function getClass($name = null) public function setClass($class) public function setFilename($filename) public function getFilename() public function getClasses() public function setBody($body) public function getBody() public function isSourceDirty() public function generate() } Laminas\\Code\\Generator\\Member\\ContainerGenerator Laminas\\Code\\Generator\\Member\\ContainerGenerator is used internally by Laminas\\Code\\Generator\\ClassGenerator to keep track of class members -- properties and methods alike. These are indexed by name, using the concrete instances of the members as values. The API of the class is as follows: class Laminas\\Code\\Generator\\Member\\ContainerGenerator extends ArrayObject { public function __construct($type = self::TYPE_PROPERTY) } Laminas\\Code\\Generator\\MethodGenerator Laminas\\Code\\Generator\\MethodGenerator describes a class method, and can generate both the code and the docblock for the method. The visibility and status as static, abstract, or final may be indicated, per its parent class, Laminas\\Code\\Generator\\AbstractMemberGenerator . Finally, the parameters and return value for the method may be specified. Parameters may be set using setParameter() or setParameters() . In each case, a parameter should either be an array of information to pass to the Laminas\\Code\\Generator\\ParameterGenerator constructor or an instance of that class. The API of the class is as follows: class Laminas\\Code\\Generator\\MethodGenerator extends Laminas\\Code\\Generator\\AbstractMemberGenerator { public static function fromReflection( Laminas\\Code\\Reflection\\MethodReflection $reflectionMethod ) public function setDocblock(Laminas\\Code\\Generator\\DocBlockGenerator $docblock) public function getDocblock() public function setFinal($isFinal) public function setParameters(Array $parameters) public function setParameter($parameter) public function getParameters() public function setBody($body) public function getBody() public function generate() } Laminas\\Code\\Generator\\ParameterGenerator Laminas\\Code\\Generator\\ParameterGenerator may be used to specify method parameters. Each parameter may have a position (if unspecified, the order in which they are registered with the method will be used), a default value, and a data type; a parameter name is required. The API of the class is as follows: class Laminas\\Code\\Generator\\ParameterGenerator extends Laminas\\Code\\Generator\\AbstractGenerator { public static function fromReflection( Laminas\\Code\\Reflection\\ParameterReflection $reflectionParameter ) public function setType($type) public function getType() public function setName($name) public function getName() public function setDefaultValue($defaultValue) public function getDefaultValue() public function setPosition($position) public function getPosition() public function getPassedByReference() public function setPassedByReference($passedByReference) public function generate() public function omitDefaultValue() } There are several problems that might occur when trying to set NULL , booleans or arrays as default values. For this the value holder object Laminas\\Code\\Generator\\ParameterDefaultValueGenerator can be used, for example: $parameter = new Laminas\\Code\\Generator\\ParameterGenerator(); $parameter->setDefaultValue( new Laminas\\Code\\Generator\\ValueGenerator(\"null\") ); $parameter->setDefaultValue( new Laminas\\Code\\Generator\\ValueGenerator(\"['foo', 'bar']\") ); Internally setDefaultValue() also converts the values which can't be expressed in PHP into the value holder. Laminas\\Code\\Generator\\PropertyGenerator Laminas\\Code\\Generator\\PropertyGenerator describes a class property, which may be either a constant or a variable. In each case, the property may have an optional default value associated with it. Additionally, the visibility of variable properties may be set, per the parent class, Laminas\\Code\\Generator\\AbstractMemberGenerator . The API of the class is as follows: class Laminas\\Code\\Generator\\PropertyGenerator extends Laminas\\Code\\Generator\\AbstractMemberGenerator { public static function fromReflection( Laminas\\Code\\Reflection\\PropertyReflection $reflectionProperty ) public function setConst($const) public function isConst() public function setDefaultValue($defaultValue) public function getDefaultValue() public function generate() public function omitDefaultValue() }","title":"Reference"},{"location":"generator/reference/#laminascodegenerator-reference","text":"","title":"Laminas\\Code\\Generator Reference"},{"location":"generator/reference/#abstract-classes-and-interfaces","text":"","title":"Abstract Classes and Interfaces"},{"location":"generator/reference/#concrete-codegenerator-classes","text":"","title":"Concrete CodeGenerator Classes"}]}